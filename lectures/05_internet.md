---
title: 05. ინტერნეტი
parent: ლექციები
---


# შესავალი
<section class="non-compulsory" markdown="1">
    
## ისტორია
1969 წელს UCLA-ის სტუდენტი ARPANET-ის ქსელში სტენფორდს [დაუკავშირდა](https://thisdayintechhistory.com/10/29/first-message-on-the-internet/).და მეორე ცდაზე მესიჯი "login" გააგზავნა. 

(რამდენი ბაიტი იქნებოდა ეს მესიჯი?)

ARPANET არის პირველი კომპიუტერული ქსელი. ამ დროს მასში ოთხი უნივერსიტეტის კომპიუტერი იყო ჩართული.
დაკავშირების შემდეგ შეეცადა სისტემაში შესულიყო, და login-ბრძანების აკრეფვისას სტენფორდის სისტემა 'დაიქრაშა'. დაახლოებით ერთ საათში მიმღები კომპიუტერის პარამეტრების შეცვლის შემდეგ მცდელობა წარმატებით დასრულდა. სურათზე ხედავთ მიმღები კომპიუტერის მსგავს მოდელს. 

![sigma9](https://hsto.org/storage2/7cf/8c3/fce/7cf8c3fcef1b5abf6d8250cf1d000ff1.jpg) 


## მოცემულობა და შეზღუდვები
4 ცალი კომპიუტერიდან 50 მილიარდამდე:

- დღეში 8 ბაიტიდან [წამში 100 000](https://www.internetlivestats.com/one-second/) გეგაბაიტამდე
- 100 000 000 000 000-ჯერ მეტი

ანუ დღეს ერთ წამში ას ტრილიონჯერ მეტი მონაცემები გაიგზავნა, ვიდრე ინტერნეტის პირველ დღეს. დღის რიცხვს ჩვენი ტვინი კიდევ უფრო ვერ აღიქვამს (ასევე მაგდენ ნოლიანს რა ქვია, ვერ ვიხსენებ). დღეში კი კიდევ 60x60x24=86,400-ჯერ უფრო მეტი.
</section>

ერთი ინტერნეტ პაკეტი პლანეტის ერთი ბოლოდან მეორემდე 10-20 კომპიუტერს გაივლის და ამას 0.1 მილიწამსაც კი არ ანდომებს

და მნიშვნელოვანია ისიც, რომ ამ ყველა კომპიუტერს შორის სხვადასხვა კავშირია. ჯერ wifi-თ უკავშირდები შენს როუტერს, რომელიც სახლში დგას. როუტერი უკავშირდება მოდემს, რომელიც ანაწილებს ინტერნეტ კავშირს შენობაში. შეიძლება ქუჩაზე ჯერ ოპტიკური კაბელი არ არის, ანუ რაღაც მომენტში გადაერთვება ერთიდან მეორეზე. თუ ოკეანის გადაღმა გზავნით, თითქმის მთელი ევროპის პაკეტებთან ერთად იგზავნება უზარმაზარი ტრანს ატლანტიკური კაბელით.

![](https://mocomi.com/wp-content/uploads/2016/10/MOC_GIFO_INTERNET.gif)


## პრობლემები, რომლებიც უნდა გადავჭრათ
- როგორ გავიგოთ ყველაზე მოკლე გზა ერთი კომპიუტერიდან მეორემდე
- დაკარგული/სხვადასხვა მიმდევრობით მისული პაკეტები
- სხვადასხვა მედიუმის გამოყენება კავშირისთვის


## მთავარი პრინციპები
როგორ არის შესაძლებელი, რომ ინტერნეტი ასეთი მასშტაბური, მრავალფეროვანი და სწრაფი იყოს? და უფრო მეტიც, ნახევარი საუკუნის წინ შექმნილი მოდელს დღეს მილიარდობით მოწყობილობა უპრობლემოდ იყენებდეს? მთავარი მიზეზი ის არის, რომ ინტერნეტისთვის საჭირო ფუნქციები დაყოფილია ერთმანეთისგან მკაცრად იზოლირებულ შრეებად, ისე, რომ სხვადასხვა გადაჭრებმა ერთმანეთს ხელი არ შეუშალონ. ამ შრეების გაცნობის შემდეგ უკეთ გაიგებთ რაზე ვსაუბრობ. ნებისმიერი დიდი და რთული სისტემის შექმნისას აუცილებელია შემადგენელი ელემენტები რაც შეიძლება მინიმალისტური იყოს. ეს სტრატეგია ხშირად გამოიყენება კომპიუტერულ მეცნიერებებში (გაიხსენეთ დეკომპოზიცია). 

თითოეულ შრეს აქვს ორი მთავარი კომპონენტი

#### ინტერფეისი
პასუხისმგებლობა, რომლის შესრულებასაც პირდება შრე (ან სერვისი, ფუნქცია). ინტერფეისი პასუხობს კითხვას **რა** და არა **როგორ**. ინტერფეისს სრული თავისუფლება აქვს, როგორც უნდა ისე შეასრულოს ნაკისრები ვალდებულება. განსაზღვრული (რასაც უნდა დაემორჩილოს) არის მხოლოდ მოცემულობა და შედეგი. რაც უფრო პატარა და კარგად განსაზღვრულია პასუხისმგებლობა, უფრო მეტ სხვადასხვა პრობლემაზე შეგვიძლია გამოვიყენოთ ეს სერვისი. 

#### პროტოკოლი
წინასწარ შეთანხმებული პრინციპები, რომლითაც ერთი შრის ორი სუბიექტი ერთმანეთს უკავშირდება. მაგალითად, იმისთვის, რომ wifi კავშირი გვგქონდეს, გვჭირდება wifi სიგნალის გამცემი და ჩვენს კომპიუტერზე ან ტელეფონზე მისი მიმღები. Wifi-ს bluetooth-ით ვერ დავუკავშირდებით. მიუხედავად იმისა, რომ ეს ორი პროტოკოლი ერთი და იმავე პასუხისმგებლობას ასრულებს (მონაცემთა გადაცემა ერთი მოწყობილობიდან მეორეში), მათ ერთმანეთის არ ესმით.



# ინტერნეტის შრეები
## 1. Physical layer

### პასუხისმგებლობა
ციფრული სიგნალის ანალოგურში (და პირიქით) გადათარგმნა

![analog to digital](https://binaryupdates.com/wp-content/uploads/analog-to-digital-conversion.jpg)

ჩიპის გამოყენებით მიღებული ინფორმაციის წაკითხვა/ჩაწერა ისევე შეიძლება, როგორც მეხსიერებიდან - უბრალოდ 1 და 0-ების მიმდევრობას ვიღებთ.

![](https://www.researchgate.net/publication/309595949/figure/fig2/AS:424332557066241@1478180173228/Digital-to-analog-modulation-14.png)

### პროტოკოლები
- dsl
- Bluetooth
- ethernet/wifi
- usb

usb განსაკუთრებით მძლავრი პროტოკოლია, დააკვირდით რამდენი სრულიად განსხვავებული მოწყობილობა იყენებს - პორტატული დრაივი, პრინტერი, MIDI

## 2. Data Link layer

თუ გვჭირდება 50 მილიარდი კომპიუტერი დავაკავშიროთ, პირველი, რასაც უნდა შევაცადოთ, არის 2 კომპიუტერის დაკავშირება.

### პასუხისმგებლობები
- ფიზიკურ შრეზე დაკავშირებულ ორ მოწყობილობას შორის ინფორმაციის მიმოცვლა
- ფიზიკურ შრეზე დაკარგული ინფორმაციის აღმოჩენა/კორექტირება
- ინფორმაციის დასაწყისის და დასასრულის მონიშვნა (რომ უწყვეტად მიდიოდეს კავშირი). რამდენიმე სხვადასხვა გზავნილის დაჯგუფება (და შემდეგ განცალკევება), რომ ფიზიკური კავშირი მაქსიმალური ეფექტურობით იყოს გამოყენებული. 


#### Error Control
ფიზიკურ შრეზე დაშვებული შეცდომების გამოსწორება იმის გათვალისწინებით, თუ რომელი პროტოკოლი გამოიყენება ფიზიკურ შრეზე. wifi ტალღები ბევრად უფრო მარტივად დაზიანებადია (შესაბამისად მესიჯის ნაწილები იკარგება გზაში), ვიდრე კაბელში გამავალი ნაკადი. მათემატიკურად შესაძლებელია გადაცემისას დაფიქსირებული შეცდომების პოვნა და გამოსწორება, თუმცა ამისთვის საჭიროა მესიჯისთვის დამატებითი ინფორმაციის დართვა (იმის მიხედვით, რამდენად დიდ დაზიანებასთან გამკლავება გვსურს). თუ კავშირი სანდოა (შნური), უაზროდ გამოვიყენებდით ამ ალგორითმებს და გავზრდიდით ყველა მესიჯის ზომას.

<section class="non-compulsory" markdown="1">
    
A simple example of how this works using metadata is transmitting the word "HELLO", by encoding each letter as its position in the alphabet. Thus, the letter A is coded as 1, B as 2, and so on as shown in the table on the right. Adding up the resulting numbers yields 8 + 5 + 12 + 12 + 15 = 52, and 5 + 2 = 7 calculates the metadata. Finally, the "8 5 12 12 15 7" numbers sequence is transmitted, which the receiver will see on its end if there are no transmission errors. The receiver knows that the last number received is the error-detecting metadata and that all data before is the message, so the receiver can recalculate the above math and if the metadata matches it can be concluded that the data has been received error-free. Though, if the receiver sees something like a "7 5 12 12 15 7" sequence (first element altered by some error), it can run the check by calculating 7 + 5 + 12 + 12 + 15 = 51 and 5 + 1 = 6, and discard the received data as defective since 6 does not equal 7.

</section>

## 3. Network Layer

რადგანაც ფიზიკური კავშირის პრობლემა მოგვარებულია, შეგვიძლია დავივიწყოთ, ქსელში რომელი ორი წყვილი რა გზითაა დაკავშირებული. აქ უბრალოდ იმაზე უნდა ვიფიქროთ, ყველაზე სწრაფი გზით როგორ მოვაგვაროთ ჩამოთვლილი პრობლემები. 

![](https://i.gifer.com/L6dm.gif)

### პასუხისმგებლობები
- ქსელის ორ წერტილს (კომპიუტერს) შორის ყველაზე მოკლე (სწრაფი) გზის პოვნა
- ქსელის დატვირთვის გადანაწილება 

### პროტოკოლები
აქამდე განხილული შრეები მხოლოდ ორი კომპიუტერის დაკავშირებას ეხება. ქსელში ბევრი კომპიუტერი შედის და ერთმა მესიჯმა რამდენიმე მათგანი უნდა გაიაროს. ამისთვის მნიშნველოვანია, რომ ყველამ იცოდეს სად გადააგზავნოს მესიჯი. ამიტომ ინტერნეტში ქსელის ერთი პროტოკოლი არსებობს - IP მისამართი, უნიკალური იდენთიფიკატორი, რომელიც ქსელში ჩართულ ყველა კომპიუტერს აქვს. 

### გზის პოვნა ორ მოწყობილობას შორის
ყველაზე მნიშვნელოვანი გზის გამოთვლაა. ყველა გადამრთველმა რომ ყველა დანარჩენთან გზა გამოთვალოს და დაიმახსოვროს, ორ პრობლემას წააწყდება:
- არ ეყოფა დრო და ადგილი მეხსიერებაში 
- ეს გზა ყოველ წამს იცვლება და ასეულობით წელი რომც არ ჭირდებოდეს ამ გამოთვლას, ერთ წამში უკვე უსარგებლო იქნებოდა. 

ამიტომ იმის მაგივრად, რომ მთლიანი გზა დაიმახსოვრონ, ინტერნეტში თითოეულ გადამრთველს აქვს ცხრილი სხვა მისამართების და იმახსოვრებს მხოლოდ შემდეგ გაჩერებას ამ მისამართის (ან მისამართების ჯგუფის გზაზე). დაფიქრდით, ერთი ქალაქიდან მეორეში ქალაქში კონკრეტულ მისამართზე რომ მიდიოდეთ. გაგიჭირდებათ ვინმეს პოვნა, ვინც მთლიანი გზა დეტალურად იცის. ეს გადამრთველები ასევე პერიოდულად ამოწმებენ, რამდენად გადატვირთული არიან მათი მეზობლები და მხოლოდ ახლო გარემოზე დაკვირვების გზით ცდილობენ პაკეტთა ნაკადის განაწილებას.

![](https://www.researchgate.net/publication/324776867/figure/fig2/AS:619665818656777@1524751252557/An-example-of-routing-tables-in-a-storing-mode.png) 

### ინტერფეისის შეზღუდვები
- დაკარგული პაკეტების თავიდან გაგზავნა

ორი მიზეზის გამო არ გვაწყობს:
1. ძალიან დიდი მეხსიერება დაჭირდება რამდენიმე მილიარდ გადამრთველს, რომ გამავალი პაკეტები შეინახონ. ასევე, დიდი ზომის მონაცემთა დისკზე შესანახად ჩაწერა/წაშლა წამში ასჯერ არც ისე სწრაფია.
2. ყველა გადართვა ორჯერ უფრო მეტ ხანს გაგრძელდება, რადგან შეფერხება იქნება დასტურის მოლოდინში. ამის გამო, ეს პრობლემა შემდეგი შრის მოსაგვარებელია.


რაც შეეხება გზავნილის ზომას, დიდი გზავნილის პატარებად დაყოფა ნიშნავს, რომ ქსელში სხვადასხვა გზით შეძლებენ წასვლას და უფრო მალე მივა ყველა ერთად, ვიდრე ერთი მეორის დალოდებისას. კიდევ რამდენიმე სხვა მიზეზის გამო, ინტერნეტ პაკეტები საკმაოდ მცირეა და მესიჯების დიდი (მაგრამ არა ყველა) ნაწილი უნდა დაიშალოს და მიღებისას აიწყოს.


## 4. ტრანსპორტი
### პასუხისმგებლობები
- პაკეტების დანომვრა, აწყობა
- დაკარგული პაკეტების აღმოჩენა და თავიდან გაგზავნა

ამ პრობლემის მოგვარების ორი მთავარი გზა (პროტოკოლი) არსებობს:

### პროტოკოლები
#### TCP
- ინფორმაციის მიმოცვლამდე კომპიუტერები ამოწმებენ კავშირს (3 way handshake)
- თითოეული ინტერნეტ პაკეტის გაგზავნის შემდეგ ელოდები დასტურს (ასევე ინტერნეტ პაკეტად გამოგზავნილ მესიჯს). 

![](https://www.researchgate.net/profile/Roberto-Bifulco-2/publication/305081696/figure/fig2/AS:643173193879554@1530355847765/3-way-handshake-3-way-handshake-and-Proxy-Early-SYN-Forwarding.png)

![](https://i.stack.imgur.com/fVsBQ.png)



##### რა შემთხვევებში არის ეს პროცედურა ზედმეტი?
- ვიდეო ზარი - 2 წამის წინანდელი ნათქვამი რაში გვჭირდება?

კავშირის და ყოველი პაკეტის დასტურის გზავნა და ლოდინი დროის მხრივ ძვირი ოპერაციებია და ყოველთვის არ ღირს.

#### UDP
ინტერნეტ პაკეტს აგზავნი და წარმატებებს უსურვებ :)

თუ არ ვამოწმებთ მივიდა თუ არა, აბა საიდან იგებენ აპლიკაციები, რომ ცუდი კავშირი გვაქვს?

განსხვავების უკეთ გასაგებად რამდენიმე მაგალითი:
- <https://images-cdn.9gag.com/photo/an5d7xV_700b.jpg>
- <https://i.redd.it/duv11av99nm11.png>

## 5. აპლიკაცია
კომპიუტერულ პროგრამებს ახლა ისღა დარჩენიათ, გადაწყვიტონ რომელი პროტოკოლი უნდათ - tcp თუ udp და როგორმე გაიგონ მესიჯის მიმღების IP მისამართი. სხვა ყველაფერი მათი საზრუნავი (და აწი თქვენიც) აღარაა.