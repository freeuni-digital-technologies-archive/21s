---
title: 04. ოპერატიული სისტემა, ფაილები, პროგრამები
parent: ლექციები
---

# ინფორმაციის ენკოდირება ბაიტებში (და უკან)
ჩვენ ვისწავლეთ, რომ კომპიუტერში ინფორმაცია ბიტებში ინახება და მუშავდება, მაგრამ ჯერ შეუძლებელია იმის აღქმა, თუ როგორ გადაითარგმნება სხვადასხვა სახის ინფორმაცია (სურათი, ვიდეო, აუდიო, ტექსტი) ბიტებში.

ამ ლექციაში შევეცდებით კარგად გავიგოთ, რას ნიშნავს, როდესაც ვამბობთ რომ კომპიუტერში ყველაფერი არის რიცხვი. როგორ შეიძლება, რომ მხოლოდ და მხოლოდ ციფრების მიმდევრობით მუშაობდეს ყველა ციფრული პროგრამა, რომელსაც ვიყენებთ?

### სურათები
დავიწყოთ ყველაზე პრიმიტიული მაგალითით.

![](https://futureeverythingmsf.files.wordpress.com/2015/02/image.png)

თითო უჯრას **პიქსელი** ეწოდება. როგორ გავაუმჯობესოთ სურათის ხარისხი?

![](https://images.ctfassets.net/1khq4uysbvty/3ilqI18qg7SJCwSvj52GWr/6a6a08e458503ed55db4651035763b49/pixel_density.png?&w=736)

1. გავზარდოთ პიქსელების რაოდენობა ![](https://kronos-images.schoolmouv.fr/2-fnx-snt-c15-img01.png)
2. გავზარდოთ ერთ პიქსელში ბიტების რაოდენობა - ორის მაგივრად მეტი ფერი გვგქონდეს - თუ თითო პიქსელი ერთი ბაიტი იქნება, მაშინ 255 ფერს გამოვსახავთ (ნაცრისფერის ტონები) 

![](https://seis.bristol.ac.uk/~ggjlb/teaching/ccrs_tutorial/tutorial/graphics/content/pixel.gif)

#### ფერები
ციფრულ ფორმატში ფერები გამოისახება **rgb** მნიშვნელობის გამოყენებით. თითო საბაზისო ფერისთვის (წითელი, მწვანე, ლურჯი) გამოყოფილია ერთი ბაიტი - ანუ ერთი პიქსელისთვის სამ ბაიტს ვინახავთ.

#### სურათის გამოსახვა ეკრანზე
სურათის პიქსელებად შენახვა ზუსტად შეესაბამება იმ პრინციპს, როგორც ახლა ეს გამოსახულება შენს ეკრანზეა შექმნილი. 
ყველა ეკრანს აქვს **რეზოლუცია**,მაგალითად, Full HD - 1920x1080. ეს ნიშნავს, რომ ეკრანზე არის 2,073,600 კვადრატი, რომელშიც თავისდავად 3-3 მართკუთხედია - ლურჯის, წითელის და მწვანესთვის. rgb მნიშვნელობა სწორედ ასე გამოისახება.

![](https://ak.picdn.net/shutterstock/videos/1040393114/thumb/1.jpg)

### კომპრესირება
ერთი fhd სურათის ზომა 6,220,800 ბაიტი ანუ 6 MB (მეგაბაიტი) იქნება. შეიძლება ცალკე აღებულად არც ისე დიდი ზომაა, მაგრამ ზოგჯერ ამ ზომის შემცირება გვჭირდება (ჩვენ ან სხვას). წარმოიდგინეთ, რამდენი სურათი იპოსტება/იგზავნება სოციალურ მედიაში ყოველ წამს. ისიც გეცოდინებათ, რომ მესენჯერში გაგზავნისას სურათი "ხარისხს კარგავს". 
სურათის ზომის შემცირება ერთი შეხედვით მარტივი, მაგრამ არც ისე პრიმიტიული პრობლემაა. რა ლოგიკით გადავწყვიტოთ, რომელი პიქსელები ამოვაგდოთ? ჩვენ უბრალოდ ზომის შემცირება ხომ არ გვინდა - გვსურს 
ამ პროცესს კომპრესირება ეწოდება და სურათების შენახვის გარდა ბევრ სხვა ფაილშიც გამოიყენება.

### სურათის შენახვის ფორმატები
#### JPEG
კონკრეტული სიგანის (მაგალითად 2) კვადრატებზე "საშუალოს" აღება და ამ 4 (2x2) პიქსელის მაგივრად 1 მნიშვნელობის ჩაწერა
![](https://cdn.geckoandfly.com/wp-content/uploads/2016/12/lossy-compression-ratios.jpg)

![](https://cdn.fstoppers.com/styles/large-16-9/s3/lead/2019/12/c5cbc7dcbf92b86b43878299aea59921.jpg)
#### JPG vs PNG
png ფორმატს ბევრი უპირატესობა აქვს - არ ჩანს "გადღაბნილი" პიქსელები, არსებობს გამჭვირვალეობისთვის გამოყოფილი ბაიტი. რომელია ოპტიმალური? ამის განსაზღვრა მხოლოდ კონკრეტული შემთხვევების მიხედვით შეიძლება.
![jpg vs png](https://www.bluearcher.com/files/admin/blog-images/blogs-resources/jpg-vs-png-comparison-chart-resized-1.png)

#### RAW
გამოიყენება ფოტოგრაფიაში. კამერის სენსორის ინფორმაცია კომპრესირების გარეშე ინახება, რაც ბევრად დიდი ზომის ფაილს ქმნის, თუმცა დიდი რაოდენობით ინფორმაციას ინახავს რომელსაც კომპრესირება დაკარგავდა - ეს ფოტოს დამუშავების უფრო ხარისხიან საშუალებას გაძლევს (რის შემდეგადაც შეგიძლია გამოაქვეყნო კომპრესირებული).


### ვიდეოები
როგორ მიიღება ვიდეო? ბევრი სურათის (frame) სწრაფად ჩვენებით. მაგალითად, 30 ან 60 წამში - 30/60 **fps** (frames per second). მოდი უხეშად დავითვალოთ, რამდენი მეგაბაიტი გამოვა ერთ წუთიანი ვიდეო. რადგან ერთი კადრი 6 მეგაბაიტამდეა, ხოლო თითო წამში 60 კადრია, ერთი წამი 360 მეგაბაიტი გამოდის. ზუსტად ოთხი წამი იქნება საჭირო, რომ გეგაბაიტამდე ავიდეთ! ანუ საშუალო 32 გეგაბაიტიანი ტელეფონი ვიდეოს ორ წუთსაც ვერ ჩაიწერს. რა თქმა უნდა ეს ასე არ არის და ვიდეოს შენახვისას გამოიყენება სხვადასხვა კომპრესირების ალგორითმები, რომლებიც ვიდეოს ზომას ამცირებს. შეიძლება წამში 60 კადრია, მაგრამ მათი უმრავლესობა მხოლოდ რამდენიმე პიქსელით განსხვავდება ერთმანეთისგან - მოდი, შევინახოთ მხოლოდ ის პიქსელები, რომლებიც შეიცვალა.  

### ტექსტი
#### ascii ფორმატი
![ascii table](https://miro.medium.com/max/3284/1*DHEm7FO7ZATjvH19dmKwoA.png)
#### utf-8 ფორმატი
ascii ფორმატი ძალიან ეკონომიური იყო და სხვა გზა არც ქონდათ - თავდაპირველ კომპიუტერებში მართლა თითოეული ბაიტი ძალიან ძვირი ჯდებოდა. ამიტომ, ეს 255 ციფრი ყველა ქვეყანამ თავისთვის მოირგო - ზოგგან ლათინურ სიმბოლოებს ნიშნავდა, ზოგგან კირილიცას ასოები იყო ჩაწერილი, იაპონელებს თავიანთი იეროგლიფების ენკოდირებაზე მოუხდათ თავის მტვრევა. საბოლოოდ კი ეს ფაილები ბაბილონის გოდოლს გავდა - ერთი ქვეყნის კომპიუტერი ვერაფერს გაუგებდა მეორისას. ამიტომ (ნებაყოფლობით) შეიქმნა  კომისია, რომელიც შეთანხმდა უფრო ფართო - 8 ბაიტიან ფორმატზე, სადაც ყველა ანბანი ჩაეტეოდა.

### არქივები (zip, rar)
ფაილებზე ოპერაციას აქვს ფიქსირებული დანახარჯი ერთ ფაილზე. მაგალითად, თუ ვაკოპირებთ ათ ცალ 100MB ფაილს, ეს პროცესი უფრო დიდ დროს წაიღებს, ვიდრე ერთი ცალი 1000MB ფაილი. ეს ფიქსირებული დანახარჯები არის, მაგალითად, გადაკოპირების ადგილას იმის შემოწმება, არის თუ არა ფაილისთვის საკმარისი ადგილი. შემდეგ გადაკოპირების ადგილას სპეციალური ცხრილის შეცვლა, რომ იმ ფოლდერში ახალი ფაილი ემატება და ა.შ. ეს დიდი პრობლემა ხდება, როდესაც საქმე ასობით ან ათასობით ფაილს ეხება. 

არქივების კიდევ ერთ პასუხისმგებლობა არის კომპრესირება - იმის ცოდნის გარეშე, თუ რა ფორმატის ფაილია. მარტივი მაგალითი, თუ ფაილის რიცხვითი მნიშვნელობა არის 131237333338588888222211111334, ძალიან ბევრ რიცხვს ვამეორებთ. ჩვენ შეგვიძლია შემოვიღოთ ნიშანი G, რაც იგულისხმებს, რომ მის შემდეგ იმის მაგივრად, რომ 5 ცალი 3 დავწეროთ, დავწერთ, რომ 5 ცალი 3 არის იმ ადგილას. 131237G5385G58G42G51334. ჩვენი 'ფაილის ზომა' 30 სიმბოლოდან 23-მდე ჩამოვიდა. ეს კი ათობით სისტემაში - ორობითში გამეორებები ბევრად უფრო ხშირია. დეკომპრესირებისას ფაილი უბრუნდება თავდაპირველ ზომას.

ამ ორივე პროცესის შებრუნებას - ამოარქივებას და დეკომპრესირებას - სჭირდება გამოთვლა და შესაბამისად დრო - ფაილის ყოველ ჯერზე გასახსნელად არ გამოდგება. არქივებს იყენებენ გასაგზავნად, გადასაკოპირებლად ან გრძელვადიანი შენახვისთვის

# პროგრამები

## რა არის პროგრამა
პროცესორის ინსტრუქციების ერთობლიობა კონკრეტული დავალების შესასრულებლად.

### პროგრამის დაყენების პროცესი
### პროგრამის გაშვების პროცესი


## რა არის ინტერფეისი
წინასწარ შეთანხმებული ან მოწოდებული მოწყობილობა ან სისტემა (აბსტრაქციასთან) ინტერაქციისთვის. მაგალითად, როდესაც ჩვენს ლეპტოპს ან კომპიუტერს ვუერთებთ პრინტერს, ეს პრინტერი აინსტალირებს ე.წ. დრაივერს - ასწავლის ჩვენს კომპიუტერს, რა ინსტრუქციაზე რა ბრძანებას შეასრულებს. ამის შემდეგ, ჩენმა ლეპტოპმა იცის, რომ როდესაც ამ პრინტერის მონიშვნით დავაჭერთ დაბეჭდვის ღილაკს, 

ინტერფეისი ეწოდება, ასევე, კარელის ბრძანებების ერთობლიობას, რომელიც თქვენ იცით, რომ ედიტორში დაწერისას იმუშავებს.

ინტერფეისი არის კომპიუტერთან და პროგრამებთან ინტერაქციის გზაც
- gui graphical user interface მაუსისა და ფანჯრების მეშვეობით ინტერაქცია
- cli command line interface ტერმინალში შეყვანილი ბრძანებებით ინტერაქცია

ხშირ შემთხვევაში ერთი თასქის შესრულება ორივე გზით არის შესაძლებელი. თუმცა ბევრ პროგრამას მხოლოდ ერთ-ერთი ინტერფეისი აქვს.

მაგალითად, იმისთვის რომ Word ფორმატის ფაილიდან pdf შევქმნა, Microsoft Office უნდა გავხსნა, შევიდე მენიუში და ა.შ. ალტერნატიული პროგრამა, Libreoffice-ს კი გარდა ამ გზისა, აქვს cli ინტერფეისი, სადაც შეგიძლია ათობით ფაილი ერთი ტექსტის დაწერით გადააკონვერტირო.

```sh
mkdir my-folder
cd my-folder
libreoffice --headless --convert-to pdf my.docx
libreoffice --headless --convert-to pdf *.docx #რაც ამ ფოლდერში docx ფაილი არის, ყველა გადააკონვერტირე pdf-ად
```

### cli interface უპირატესობები
- შესაძლებელია ბრძანებების შენახვა სხვადასხვა დავალებების ავტომატიზირებისთვის
- შესაძლებელია პროგრამირების ენის შესაძლებლობების გამოყენება
- უფრო მარტივი და სწრაფია სხვა კომპიუტერთან დისტანციური კავშირი (და იმ კომპიუტერზე ბრძანებების შესრულება). გრაფიკული დისტანციური კავშირის პროგრამაა, მაგალითად, teamviewer
- ბრძანებების დამახსოვრების შემდეგ უბრალოდ იწყებ იმის წერას, რისი გაკეთებაც გინდა, და auto-complete ფუნქციით გეხმარება ტერმინალი

### os interface
ყველა პროგრამა თავიდან არ წერს სურათის ეკრანზე გამოსახვის კოდს - უბრალოდ ოპერატიულ სისტემას აძლევს კონკრეტული რეზოლუციის პიქსელებს. ოპერატიული სისტემაა პასუხისმგებელი კლავიატურის, მაუსის, სხვადასხვა გარე მეხსიერების და მოწყობილობების მართვაზეც.


# ოპერატიული სისტემა
## მთავარი პასუხისმგებლობები
- პროცესების მართვა: რომელი პროგრამის გაშვების ჯერია, რომელმა პროგრამამ გაჭედა
- ფიზიკური ნაწილების მართვა და დაცვა:
    + რომელ პროგრამას რა მეხსიერებაზე აქვს წვდომა
    + პერიფერიების (usb, disk, ethernet, wifi card, sound card) დაკავშირება
- ფაილების მართვა

სხვა ყველაფერი არის დამატებითი პროგრამა (მაგალითად, ფაილის შესაბამისი პროგრამის პოვნა, რომ პროგრამის გახსნის გარეშე ჩაირთოს)


### ლინუქსი
windows-ზე ეს პროგრამები ავტომატურად არის დაყენებული და მისი შეცვლა ან კონფიგურაცია თითქმის შეუძლებელია. ლინუქსზე ყველაფერი სხვანაირადაა - არის ბევრი ალტერნატივა იმის, თუ როგორი არის ოპერატიული სისტემა და ხშირ შემთხვევაში ყველაფერზე კონტროლი გაქვს. თუ უველაფრის სათითაოდ არჩევა არ გინდა, არსებობს ბევრი წინასწარ შერჩეული Desktop Environment, რომლებიც unified experience-ს სთავაზობენ მომხმარებელს.

დამატებითი პროგრამები
- **display manager**
- **window manager**
- **panel**
- **file explorer**
- **notification service**







