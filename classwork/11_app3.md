---
title: 11. ვებ აპლიკაცია 3 - რეფაქტორინგი
parent: სემინარები
---


- საწყისი ფაილები: 10_app2
- საბოლოო ფაილები: 11_app3

## რეფაქტორინგი

დეკომპოზიცია (კოდის დაყოფა მარტივ ნაწილებად) პროგრამირების ერთერთი უმთავრესი ნაწილია, რომელიც კოდს ხდის უფრო მარტივს, როგორც საკუთარი მოხმარებისთვის ასევე სხვა პროგრამისტებისთვის. ამ დროს შენ ცდილობ კოდის მარტივ ნაწილებად, მარტივ ფუნქციებად ჩაშლას რის შედეგადაც კოდი ხდება ბევრად უფრო მარტივი დასაწერი და კითხვადი.

#### წინა სემინარზე გარჩეული კოდის ჩაშლა მარტივ ნაწილებად
ამ სემინარის მასალაში ავხსნით თუ წინა ნაწილის createNewPost() ფუნქცია როგორ ჩავშალეთ ოთხ დამხმარე ფუნქციად (cratePost(), addPost(post), getPostElem(post), getPostLikesElem(post))
დავიწყოთ პირველი ფუნქციით
```js
function createPost() {
	let textElem = document.getElementById('new-post-text')
	let post = {
		text: textElem.value,
		likes: 0,
		id: POSTS_ID
	}
	POSTS_ID++
	addPost(post)
}
```
ფუნქციის პირველი ხაზით ამოვიღებთ დოკუმენტიდან შესაბამის ელემენტს. შემდეგ წინა სემინარისგან განსხვავებით პოსტს შევუქმნით ცალკე ელემენტს, რომელსაც უკვე ექნება შესაბამისი სამი ველი: ტექსტი, ლაიქების რაოდენობა და id. ტექსტს შესაბამისად მივანიჭოთ textElem.value მნიშვნელობა, ლაიქების თავდაპირველი მნიშვნელობა იყოს 0, ხოლო id ჩვენს მიერ შემოღებული ცვლადი POSTS_ID, რომელიც უნდა იყოს უნიკალური თითოეული პოსტისთვის და რომლის მიხედვითაც უნდა შეგვეძლოს პოსტის ამოცნობა (როგორც ჩვენ ამოვიცნობით ჩვენი პირადი ნომრით ისე უნდა იყოს ეს id პოსტისთვის). შემდეგ უკვე ეს უნიკალურობა რომ არ დაირღვეს POSTS_ID გავზარდოთ ერთით, რადგან უკვე შემდეგი პოსტის შექმნა რომ გვენდომება მას მიენიჭოს ერთით მეტი მნიშვნელობა. ბოლოს კი უკვე ამ პოსტ ელემენტის მიხედვით დავამატოთ ახალი პოსტი addPost(post) ანუ ამ ფუნქციას გადავეცით ჩვენს მიერ აღწერილი პოსტ ელემენტი, რომლის მიხედვითაც ის დაამატებს შესაბამის პოსტს.
```js
function addPost(post) {
	let postsElem = document.getElementById('posts-container')
	let postElem = getPostElem(post)
	postsElem.insertAdjacentHTML('afterbegin', postElem)
}
```
ამ ფუნქციაში postsElem ამოიღებს დოკუმენტიდან, შესაბამის ელემენტს posts-container-დან, შემდეგ postElem-ს მიანიჭებს getPostElem(post) - ფუნქციის მიერ დაბრუნებულ შედეგს (ამ ფუნქიციას ქვემოთ განვიხილავთ რას და როგორ ვაკეთებთ, ამ ეტაპზე თქვენთვის მნიშვნელოვანია უბრალოდ ჩათვალოთ, რომ ის თავის საქმეს შეასრულებს და მართლაც დააბრუნებს სასურველ პასუხს). ბოლოს კი უკვე postsElem-ს afterbegin-ით ვამატებთ შესაბამის postElem-ს.
```js
function getPostElem(post){ 
	let likesElem = getPostLikesElem(post)
	return `
		<div class="post-container" id="post${post.id}">
			<div class="post-text">
				${post.text}
			</div>
			${likesElem}
		</div>
	
```
ამ ფუნქციას უკვე არგუმენტად გადმოეცემა შესაბამისი პოსტი და მისი მიზანია დააბრუნოს შესაბამისი div ელემენტი, ამისათვის პირველ რიგში უნდა ვიპოვოთ ლაიქების შესაბამისი HTML კოდი და გავუტოლოთ likeElem-ს, ამ ყოველივეს ჩავთვალოთ რომ getPostLikesElem(post) ფუნქცია ასრულებს. ბოლოს კი ამ ფუნქციას დავაბრუნებინოთ შესაბამისი HTML კოდი რომელიც წინა ნაწილებში გარჩეული გვაქვს, უბრალოდ likeElem აქ გატანილია ცალკე ფუნქციად, რომელიც კოდის კითხვადობას ამარტივებს. ასევე ტექსტი და აიდი უკვე პოსტ ელემენტის დახმარებით მიენიჭება (post.id, post.text)
```js
function getPostLikesElem(post) {
	return `<span class="post-likes-number">${post.likes}</span> likes
			<button onclick="likePost(${post.id})" class="post-like-button">like</button>`
}
```
ეს ფუნქცია კი შესაბამისად დააბრუნებს ლაიქების რაოდენობის და ლაიქის ღილაკის HTML კოდს. საბოლოოდ ჩვენი createNewPost ფუნქცია იშლება ამ ოთხ ფუნქციად. ზოგისთვის ეს კოდი შესაძლოა ბევრად უფრო რთული იყოს გასააზრებლად და წინა სემინარებზე გარჩეული კოდი ერჩივნოს დასაწერად, მაგრამ როდესაც საქმე უკვე შედარებით დიდ კოდებს შეეხება დეკომპოზიციით და კოდის პატარა ნაწილებად დაყოფა ბევრად უფრო ეფექტური და კითხვადი მიდგომაა.
