---
title: 11. ვებ აპლიკაცია 3 - რეფაქტორინგი
parent: სემინარები
---


- საწყისი ფაილები: 10_app2
- საბოლოო ფაილები: 11_app3

## რეფაქტორინგი
დეკომპოზიცია (კოდის დაყოფა მარტივ ნაწილებად) პროგრამირების ერთერთი უმთავრესი ნაწილია, რომელიც კოდს ხდის უფრო მარტივს, როგორც საკუთარი მოხმარებისთვის ასევე სხვა პროგრამისტებისთვის. ამ დროს შენ ცდილობ კოდის მარტივ ნაწილებად, მარტივ ფუნქციებად ჩაშლას რის შედეგადაც კოდი ხდება ბევრად უფრო მარტივი დასაწერი და კითხვადი.

#### წინა სემინარზე გარჩეული კოდის ჩაშლა მარტივ ნაწილებად
ამ სემინარის მასალაში ავხსნით თუ წინა ნაწილის createNewPost() ფუნქცია როგორ ჩავშალეთ ოთხ დამხმარე ფუნქციად (cratePost(), addPost(post), getPostElem(post), getPostLikesElem(post))
დავიწყოთ პირველი ფუნქციით
```js
function createPost() {
	let textElem = document.getElementById('new-post-text')
	let post = {
		text: textElem.value,
		likes: 0,
		id: POSTS_ID
	}
	POSTS_ID++
	addPost(post)
}
```
ფუნქციის პირველი ხაზით ამოვიღებთ დოკუმენტიდან შესაბამის ელემენტს. შემდეგ წინა სემინარისგან განსხვავებით პოსტს შევუქმნით ცალკე ელემენტს, რომელსაც უკვე ექნება შესაბამისი სამი ველი: ტექსტი, ლაიქების რაოდენობა და id. 
- ტექსტს შესაბამისად მივანიჭოთ textElem.value მნიშვნელობა
- ლაიქების თავდაპირველი მნიშვნელობა იყოს 0
- id ჩვენს მიერ შემოღებული ცვლადი POSTS_ID, რომელიც უნდა იყოს უნიკალური თითოეული პოსტისთვის და რომლის მიხედვითაც უნდა შეგვეძლოს პოსტის ამოცნობა (როგორც ჩვენ ამოვიცნობით ჩვენი პირადი ნომრით ისე უნდა იყოს ეს id პოსტისთვის). შემდეგ უკვე ეს უნიკალურობა რომ არ დაირღვეს POSTS_ID გავზარდოთ ერთით, რადგან უკვე შემდეგი პოსტის შექმნა რომ გვენდომება მას მიენიჭოს ერთით მეტი მნიშვნელობა. 

ბოლოს კი უკვე ამ პოსტ ელემენტის მიხედვით დავამატოთ ახალი პოსტი addPost(post) ანუ ამ ფუნქციას გადავეცით ჩვენს მიერ აღწერილი პოსტ ელემენტი, რომლის მიხედვითაც ის დაამატებს შესაბამის პოსტს.

ახლა `addPost()`-ზე გადავიდეთ. პირველი ხაზი იგივე რჩება, უბრალოდ ვპოულობთ posts-container ელემენტს. შემდეგ შევქმნათ ახალი პოსტის ელემენტი. `getPostElem()` ფუნქციის იმპლემენტაციას მომდევნო ნაბიჯზე გავაკეთებთ, ამ ეტაპზე უბრალოდ ჩათვალეთ, რომ ის თავის საქმეს შეასრულებს და მართლაც დააბრუნებს სასურველ პასუხს, როგორ, არ არის მნიშვნელოვანი და ხელს შეგვიშლის ფუნქციის ახლანდელ პრიორიტეტზე კონცენტრაციაში. მიღებულ ელემენტს უბრალოდ ვამატებთ პოსტების კონტეინერის დასაწყისში.
```js
function addPost(post) {
	let postsElem = document.getElementById('posts-container')
	let postElem = getPostElem(post)
	postsElem.insertAdjacentHTML('afterbegin', postElem)
}
```

getPostElem ფუნქციას უკვე არგუმენტად გადმოეცემა პოსტის ობიექტი და მისი მიზანია დააბრუნოს შესაბამისი div ელემენტი. ამისათვის პირველ რიგში უნდა შევქმნათ ლაიქების ელემენტი, ესეც სხვა ფუნქციას - getPostLikesElem(post) გადავაბაროთ და მიღებული შედეგი ჩავსვათ ჩვენს მიერ დაბრუნებულ html string-ში. 

ამ სტრინგით დაბრუნებულ HTML კოდში ყველაფერი თითქმის იგივეა, იმ განსხვავებით, რომ კოდის წაკითხვა უფრო მარტივია. ასევე მნიშვნელოვანია, რომ ტექსტი და აიდი უკვე პოსტ ობიექტიდან იკითხება, რაც უფრო ინტუიტიურია. პოსტისთვის სხვა ატრიბუტების დამატების შემთხვევაში აღარ მოგვიწევს არგუმენტების სიის გაზრდა, getPostsElem უბრალოდ ობიექტს გადავაწვდით ხოლმე და იქ წავიკითხავთ საჭირო ატრიბუტებს.

```js
function getPostElem(post){ 
	let likesElem = getPostLikesElem(post)
	return `
		<div class="post-container" id="post${post.id}">
			<div class="post-text">
				${post.text}
			</div>
			${likesElem}
		</div>
	
```

```js
function getPostLikesElem(post) {
	return `<span class="post-likes-number">${post.likes}</span> likes
			<button onclick="likePost(${post.id})" class="post-like-button">like</button>`
}
```

საბოლოოდ, ჩვენი createNewPost ფუნქცია იშლება ამ ოთხ ფუნქციად. ერთი შეხედვით, ეს კოდი შესაძლოა ბევრად უფრო რთული იყოს გასააზრებლად და უფრო ბევრიც ჩანდეს, მაგრამ ეს ფუნქცია ახალი ფუნქციონალის დამატების შემთხვევაში უფრო და უფრო გაიზრდებოდა და რთული იქნებოდა კონკრეტული პასუხისმგებლობების გარჩევა, რაც მეტი შეცდომის დაშვებით დასრულდებოდა.


