---
title: 07. ცვლადები და ფუნქციის return (კარელში)
parent: სემინარები
---

## ცვლადები
### ახალი ცვლადის შექმნა, შეცვლა და გამოყენება
ცვლადები არიან ტიპები სადაც შეგვიძლია საჭირო ინფორმაციის შენახვა და შემდგომ კი უკვე მათი სხვადასხვა ადგილას გამოყენება. ცვლადი რომ შევქმნათ ამისათვის საჭიროა დავწეროთ var ამის შემდეგ რაც გვინდა რომ დავარქვათ ამ ცვლადს და შემდგომ კი უკვე გაუტოლოთ რაიმე ინფორმაციას (რაიმეს გატოლების გარეშეც შეგვიძლია ცვლადების დაწერა). მოცემულ მაგალითში ჯერ პირველ რიგში გადავდივართ სამჯერ წინ შემდეგ ვქმნით numberOfBalls ცვლადს და ვანიჭებთ მას 0-ის მნიშვნელობას, ამის მერე კი უკვე სანამ ბურთი დევს მოცემულ უჯრაზე ვიღებთ ბურთს და numberOfBalls ვზრდით 1-ით (numberOfBalls = numberOfBalls + 1) ანუ მას ვანიჭებთ თავის თავზე ერთით მეტ მნიშვნელობას, მათემატიკურად რომ შევხედოთ ეს შეუძლებელი ტოლობაა, პროგრამირებაში კი ეს უბრალო მინიჭების ოპერაციათ ითვლება და არა ტოლობის ოპერატორად. საბოლოოდ კი numberOfBalls ცვლადში გვექნება იმ ბურთების რაოდენობის ტოლფასი რიცხვი რამდენიც ამ უჯრაზეა. ამის შემდეგ ისევ ვაკეთებთ ერთით წინ წასვლას და უჯრაზე ვდებთ for ციკლით წინა უჯრაზე არსებულ ბურთების რაოდენობას.

```js
function moveBalls() {
    move();
    move();
    move();
    var numberOfBalls = 0;
    while (ballsPresent()) {
        takeBall();
        numberOfBalls = numberOfBalls + 1;
        // numberOfBalls++; 
    }
    move();
    for (var i=0; i<numberOfBalls; i++) {
        putBall();
    }
}
```

### ცვლადების ტიპები
ცვლადები შეიძლება იყოს მრავალგვარი მათ შეგვიძლია მივანიჭოთ სხვადასხვა მნიშვნელობები თუ შესაბამის ფუნქციონალს დავიცავთ. ისინი შეიძლება გახდნენ რიცხვები, ტექსტი თუ ბულიან მნიშვნელობები

### ცვლადების ოპერატორები
#### ლოგიკური
ბულიანები არიან ლოგიკური ოპერატორები რომლებიც ცლადს შეიძლება მიენიჭოს პირობის სისწორის ან სიმცდარის გამო და შესაბამისად შეიძლება იყოს True ან False, ლოგიკური ოპერატორების გამოყენება შეგვიძლია ციკლების პირობებშიც.

#### არითმეტიკული
არითმეტიკული ოპერაციები კი უკვე შეგვიძლია ჩავუტაროთ ციფრებს, მათზე შეგვიძლია როგორც გამრავლების ასევე გაყოფის, მიმატების, გამოკლების და სხვა მათემატიკური ოპერაციების გამოყენება

### როგორ მუშაობს for loop
ფორ ციკლის გამოძახება იყოფა სამ ნაწილად რომლებიც ერთმანეთისგან ;-ითაა ფორში გამოყოფილი. პირველ ნაწილში ხდება ცვლადის მინიჭება, მერე ნაწილში ვიყენებთ ლოგიკურ ოპერატორს, მესამე ნაწილში კი ვწერთ იმ პირობას რაც სრულდება ერთი ციკლის ნაბიჯის დასრულების შემდეგ. დეტალურად განვიხილოთ ერთერთი ფორ ციკლი რომელიც ქვევითაა მოცემული. თავდაპირველად i-სთვის ხდება 1-ის მინიჭება შემდეგ კი სანამ ეს i ნაკლები იქნება numberOfSteps-ზე მანამ იტრიალებს ციკლში და შეასრულებს ციკლის შიგნით არსებულ ინფორმაციას, ციკლის ერთი ნაბიჯის დასრულების შემდეგ კი i-ის გაზრდის ერთით, გამოდის რომ პირველ ნაბიჯზე i არის 1 და რადგან 5-ზე ნაკლებია შედის ციკლშ და ასრულებს მასში არსებულ პირობებს, შემდეგ ხდება 2 და აკეთებს იგივეს, შემდეგ 3, შემდეგ 4 და როდესაც უკვე ხდება 5 ლოგიკური ოპერაცია აღარაა ჭეშმარიტი რის გამოც ის აღარ შევა ციკლში.
```js
function forcicle() {
    var numberOfSteps = 5;
    for (int i = 1; i < numberOfSteps; i++) {
        move();
    }
}
```

## ფუნქციიდან მნიშვნელობის დაბრუნება
რატომ გვჭირდება: 
- კოდის სისუფთავისთვის (ფუნქციის ზომის შემცირება, კოდის აღსაქმელობის გასამარტივებლად, კოდის ცვალებადობის გასამარტივებლად)
- ერთი გამოთვლის რამდენჯერმე გამოსაყენებლად მაგალითად თუ გვჭირდება გავიგოთ რამდენი ბურთი დევს სხვადასხვა უჯრებზე ამისთვის ერთ უჯრაზე რამდენი ბურთია მაგ კოდის რამდენჯერმე დაწერა მოგვიწევდა თუ ფუნქციას არ გამოვიყენებდით ამ შემთხვევაში კი უბრალოდ ამ ფუნქციას გამოვიძახებთ რამდენჯერმე.
ისევე, როგორც ცვლადის სახელის დაწერის დროს რიცხვით ჩანაცვლდება ეს ცვლადი, ფუნქციის გამოძახებისას მის ადგილას დაბრუნდება ის მნიშვნელობა, რაც return-ის შემდეგ წერია


```js
function moveBalls() {
    move();
    move();
    move();
    var N = pickBalls();
    move();
    for (var i=0; i<N; i++) {
        putBall();
    }
}
function pickBalls() {
    var numberOfBalls = 0;
    while (ballsPresent()) {
        takeBall();
        numberOfBalls++;
    }
    return numberOfBalls;
}
```

# მაგალითები კარელში
## 1. შემოწმება, დევს თუ არა ბურთი
ბოლო უჯრაზე დადოს ბურთი, თუ სადმე ბურთი იდო (ბოლო უჯრაზე ვიცით, რომ ბურთი არ დევს)
```js
function checkIfBallExists() {
    var numberOfBalls = countBalls();
    if (numberOfBalls > 0) {
        putBall();
    }
}
/**
გავა ქუჩის ბოლომდე და დააბრუნებს რამდენი უჯრაზე იდო ერთი ბურთი მაინც (ბოლო უჯრის გამოკლებით)
**/
function countBalls() {
    var N = 0;
    while(frontIsClear()) {
        if (ballsPresent()) {
            N++;
        }
        move();
    }
    return N
}
```

უფრო სწორი ვარიანტი
```js
function checkIfBallExists2() {
    var ballExists = false;
    while(frontIsClear()) {
        if (ballsPresent()) {
            ballExists = true;
        }
        move();
    }
    if (ballExists) {
        putBall();
    }
}
```

## 2. სამყაროს შუა წერტილში მისვლა
```js
function goToMiddle() {
    var numberOfSquares = countSquares();
    turnAround();
    for (var i = 0; i < numberOfSquares/2; i++) {
        move();
    }
}
function countSquares() {
    var N = 1; // დააკვირდით, რატომ იწყება თვლა 1-დან
    while(frontIsClear()) {
        move();
        N++;
    }
}
```

სხვა ვარიანტი. მიუხედავად იმისა, რომ მეტი კოდი და მოძრაობაა, ორი უპირატესობა აქვს.

1. ფუნქცია ორ პასუხისმგებლობას არ ასრულებს (ბურთების დათვლასთან ერთად ადგილის, მიმართულების შეცვლა)
2. ფუნქციის გამოყენებას შევძლებთ ნებისმიერ სხვა ამოცანაში (მაგალითად, შემდეგში)

```js
function goToMiddle() {
    var numberOfSquares = countSquares();
    for (var i = 0; i < numberOfSquares/2; i++) {
        move();
    }
}
function countSquares() {
    var N = 1; 
    while(frontIsClear()) {
        move();
        N++;
    }
    turnAround();
    while(frontIsClear()) {
        move();
    }
    turnAround()
}
```

## 3. პირველ უჯრაზე სამყაროს ზომის რაოდენობის ბურთების დადება

```js
function ex3() {
    var numberOfSquares = countSquares(); // მეორე ვერსია
    for (var i = 0; i < numberOfSquares; i++) {
        putBall();
    }
}
```

## 4. მიმატება

```js
function add() {
    move();
    var numberOfBalls = 0;
    while (ballsPresent()) {
        pickBall()
        numberOfBalls++;
    }
    move();
    while (ballsPresent()) {
        pickBall()
        numberOfBalls++;
    }
    for (var i = 0; i < numberOfBalls; i++) {
        putBall();
    }
}
```

უკეთესი ვარიანტი

```js
function add() {
    move();
    var a = pickBalls();
    move();
    var b = pickBalls();
    for (var i = 0; i < a+b; i++) {
        putBall();
    }
}
```
